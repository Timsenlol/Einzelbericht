\chapter{Sprints}\label{app:Sprints}
\section{Sprint 0 24.01.2025 bis 21.02.2025}
Nach der Zusage der Verwaltung, dass wir das Projekt in der urspürnglich von uns beantragten Gruppe durchführen zu dürfen, setzten wir uns zeitnah mit Dr. Kötting in Verbindung. Hinsichtlich des Themas hatten wir noch Bedenken, da Dr Köttings initiale Projektidee, die er auch in der ersten Informationsveranstaltung dem Studiengang vorgestellt hatte uns allen nicht gefallen hatte. Im ersten Gesprächen stellte sich allerdings raus das Herr Dr. Kötting hier offen war das Thema anzupassen und daher beauftragte er uns mit der Ausarbeitung einer neuen Projektidee. Ihm war es wichtig, dass die ausgearbeitete Projektidee, Fragestellungen oder Probleme mit Hilfe von KI lösen kann.
Das Projektteam erarbeitete sich die Projektidee im Rahmen einer strukturierten Kreativitätsphase.
Hier wurde das "1-3-All"-Verfahren genutzt (angelehnt an das "1-2-4-All" Verfahren 
\cite{Desginthinking124}), um eine große Menge an Ideen zu entwickeln. Nach der Sammlung der Ideen,  stellte jede Person Ihre Ideen der Gruppe (3er Gruppe oder alle) vor, wo diese dann im Kollektiv diskutiert, verfeinert und gegeben falls zu mit anderen Ideen geclustert wurde. Abschließend hatte jeder Teilnehmer drei Stimmen um sie auf die erarbeiteten Ideen zu verteilen. Die drei Ideen mit den meisten Stimmen würden nochmal unsern Auftraggebern Dirk Kötting vorgestellt und gemeinsam diskutiert. Wichtige Faktoren waren hier der erwartbare Mehrwert für einen potenziellen Kunden und die technische Umsetzbarkeit.
Letztendlich hat sich die Projektgruppe für das Security Tool entschieden. Ausschlaggebend waren zum einem die Interessen und Kenntnisse unseres Auftraggeber, von dem dieses Projekt profitiert hat. Zum andern das dieses Projekt eine Lösungen für echte Probleme von mittelständischen Unternehmen anbietet. 
In einem anschließenden Treffen haben wir uns ein ein Codeverwaltung- und Projektmanagement-Tool geeinigt.  Für die Codeverwaltung fiel unsere Wahl auf Github, als eine der führenden Codeverwaltungsplattformen. Github ist grundsätzlich kostenlos. Ein weiterer Faktor waren die "GitHub Student Developer Packs" mit denen wir einen kostenlosen Zugang zu erweiterten Funktionen und kostenpflichtigen Angeboten erhielten (vgl \cite{github_student_pack}). 
Beim Projektmanagementtool fiel unsere Wahl auf Jira. Auch Jira ist ein im Mark etabliertes Tool im Bereich des Projektmanagement. Wir nutzen Jira zum verwalten unser Vorhaben in Form von Epics, darunter clusterten wir auch später die die jeweiligen Task, die wir in dem entsprechenden Sprint bearbeiten wollten. Für die Übersicht haben wir ein Kanban Board angelegt, wo die entsprechenden Vorhaben mit ihrem aktuellen Status für jedes Gruppenmitglied jederzeit über ihre eigenen Jira Zugänge einsehbar war. Ein wichtiger Punkt der für Jira gesprochen hatte war, dass unser Product Owner Christian Langer breites viel Erfahrung im Umgang mit Jira hatte. Er das Wissen über den Umgang mit dem Tool ins Projekt tragen.  Im nächsten Schritt habe ich mich um meine lokalen Entwicklungsumgebungen gekümmert. Da ich bereits viel Erfahrung mit den Entwicklungsumgebungen von Jetbrains hatte, wollte ich wieder auf diese setzen. Nach Recherche bin ich auf "Jetbrains Student Pack" gestoßen, welches Studenten erlaubt alle kostenpflichtigen Entwicklungsumgebungen kostenlos zu nutzen (vgl. \cite{jetbrains_student}). Initial installierte ich PyCharm und Intellij.
Innerhalb unser einzeln Workstreams haben wir nun die Anforderungen an die jeweiligen Module herausgearbeitet. Hierbei haben wir versucht aus den groben Epics, auf die wir uns mit Herrn Dr Kötting committet hatten, einzelne Anforderungen abzuleiten. Christian, Daniel und ich haben für das Phishing Modul im ersten Schritt ein grobes Ablaufdiagramm gezeichnet, um anschließend draus die einzelnen Anforderungen leichter erarbeiten zu können. Abschließend haben in der gesamten Projektgruppe die ausgearbeiteten Anforderungen vorgestellt und besprochen. Hier haben wir nochmal einige Anpassungen vorgenommen zum Beispiel hinsichtlich der zu auszuwertenden Parameter wie "Schwierigkeitsgrad". Diese Einstellung haben wir noch einigen Diskussionen zunächst verworfen.
Nachdem wir alle zufrieden mit den formulierten Anforderungen waren, haben wir diese auch nochmal unsern Auftraggeber vorgestellt um sicherzugehen, dass diese Anforderungen seinen Vorstellungen entsprechen. Dr. Dirk Kötting hat hier nochmal sehr gute Einwürfe gebracht und wir konnten die initialen Anforderungen nochmal verfeinern. Ein wichtige Anmerkung, war der Datenschutzgedanke und der Gedanke der Rechtssicherheit. Draus haben haben wir zum Beispiel die Anforderung abgeleitet, dass der Anwender vor der erstmaligen Nutzung des Moduls eine Nutzungsbedingung akzeptieren muss.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{figures/erster_Wurf_Ablauf.png} 
    \caption{Erster Wurf für den Ablauf des Phishing-Workflows}
    \label{fig:architektur1}
\end{figure}
\section{Sprint 1 21.02.2025 bis 21.03.2025}
In diesem Sprint haben wir uns mit der grundsätzlichen Architektur innerhalb des Phishing Moduls beschäftigt. Zunächst haben wir uns gemeinsam auf die Strategie geeinigt eine eigene  KI zu schreiben die Phishingmails geniert. Unter dieser Bedingung haben wir geplant ein Spring Backend zu schreiben, welches orchestrierende Aufgaben übernimmt sowie ein Python Flask Backend, welches die KI selbst aufruft.
\begin{figure}[H]
    \centering
    % Hier wird der Pfad zum Ordner "figures" angegeben
    \includegraphics[width=0.7\textwidth]{figures/EntwurfSprint1.png} 
    \caption{Entwurf der Modul Architektur im Sprint 1}
    \label{fig:architektur}
\end{figure}
Im ersten operativen Schritt habe ich das Grundgerüst des Springbootprojekts angelegt.Zu Erstellung des Projektes habe ich der Spring Initializr. Dieses kostenlose Tool ermöglicht eine geführte Erstellung der Projektstruktur. Nach Rücksprache mit Christian und Daniel haben wir uns für ein Maven Projekt in Kotlin entschieden. Maven.Die Punkte die für Maven gesprochen haben sind zum einem seine Leichtgewichtigkeit sowie meine Praxiserfahrung mit dem Buildtool. Dadurch konnte ich Christian und Daniel effizient in das Tool einarbeiten. Für Kotlin habe ich mich bewusst entschieden, denn ich wollte die Sprache im Rahmen des Projektes zu evaluieren und zu prüfen ob sie sich  eignet in meinen  Arbeitsprojekten eingesetzt zu werden. Kotlin ist eine deutlich moderene Sprache als Java und bietet einige Vorteile von denen wir auch im Rahmen unsres Projekts profitiert haben. 
\begin{itemize}
  \item \textbf{Null Saftey}: Variablen müssen explizit als "nullbar" deklariert werden. Das mindert die Gefahr von "NullPointerExceptions" erheblich. Schon während der Entwicklungsphase, hat sich dieses Feature als äußert wertvoll erwiesen. Zum einem haben wir nicht viele solcher Exceptions gehabt und wenn wir welche hatten kamen nur nullbare Variablen in Frage.
  \item \textbf{Kompakter Code}:Bolier plate Code wird drastisch reduziert. Wir konnten sehr viele Zeilen an Code sparen allein dadurch, dass Kotlin hier einfach modrner ist als Java. Zum Beispiel wird das arbeiten auf Listen deutlich vereinfacht. Wo man in Java mit einer externe Libary oder vielen If Else arbeiten muss, kann man in Kotlin auch komplexere Sachen in 2-3 Zeilen abbilden. 
\end{itemize}
Wir haben uns darüber hinaus noch auf eine Branchstrategie geeinigt (siehe 4.2 Branching Vorgehen):
Grundsätzlich wurde für jedes in der Entwicklung befindende Feature, ein Feature-Branch angelegt. Nach Fertigstellung und Code Review durch die Gruppe, wurde dieser Branch dann über einen Pull Request in den in unsern Main-Branch integriert. Darüber hinaus habe ich im aktuellen Sprin eine Github Action gebaut. Die Github Action ist so gebaut dass diese bei jedem Push oder Pull Request ausgelöst wird. Sie ist so gebaut, dass der Projekt mit Maven gebaut wird und alle Tests ausgeführt werden. Github Action waren für uns dank des "Github Student Developer Packs" kosteneffizient nutzbar für uns. 
Den Sprint haben wir abgeschlossen mit einem Sprintreview sowie einer Retrospektive, in der wir den Sprint nochmal bewertet haben.
\section{Sprint 2 21.03.2025 bis 09.05.2025}
Der Sprint wurde am 21.03.2025 in Präsenz durch unser Planning gestartet. Eine der Hauptaufgaben die wir uns für den kommenden Spring vorgenommen hatten, war die Entscheidung für eine KI-Technologie die zum Einsatz kommen sollte. Christian, Daniel und ich haben den Freitag und den Samstag nach den Vorlesungen genutzt, um im Rahmen einer Mob-Programming-Session die Möglichkeiten für die Implementierungen einer lokalen KI zu evaluieren. Wir haben unsern Schwerpunkt in das  Fine-Tuning vortrainierter Modelle gelegt, da wir den Aufbau einer neuen generativen KI nach kurzer Diskussion für deutlich zu aufwändig hielten. Mit Pythonskripten und ausgewählten Testdaten haben wir versucht eine auf unsern lokalen Endgeräten lauffähige generative KI zu erzeugen. Unsere Verfügbare Hardware stellte sich dabei immer wieder als Problem für unser Vorhaben heraus. Die Rechenkapazität unser lokalen Endgeräte war der Grund warum wir für unsere lokalen Versuche Kompromisse in der Modellgröße eingehen mussten. Unsere Versuche erstreckten uns an diesen beiden Tagen über mehrere Varianten von lokalen GPT-2 Modellen und verschiedenen lokal lauffähigen Llama-Varianten. Christian und Daniel nahmen sich für den weiteren Sprint dann vor noch tiefer in diesen Prozess einzusteigen und ich übernahm die Aufgabe Testdaten zu beschaffen und aufzubereiten. Hierfür habe ich mit über Python verschiedene E-Mail Datenbanken abgefragt und die Daten anschließend in ein JSON Format strukturiert. Um die Anzahl der Testdaten zu erweitern, habe ich mir von ChatGPT verschiedene Phising-Mails genieren lassen. Durch die Kombination der von ChatGPT generierten Daten und der abgefragten realen Daten konnte ich die Datenbasis beträchtlich erhöhen.
In unserm wöchentlichen Meeting stellte sich im Review der Ansatz einer eignen KI unter den gegebenen Rahmenbedienungen als nicht umsetzbar heraus. Die begrenzte Rechenleistung und unser eher kleiner finanzielle Rahmen machten dieses Vorhaben zu einer nicht lösbaren Aufgabe für unsere Gruppe. Wir einigten auf einen neuen Ansatz zu verfolgen, nämlich den Aufruf eines KI-Service über eine REST-API. Unsere Wahl viel auf den europäischen Anbieter Mistral AI(vgl. 5.1). In einer gemeinsamen Mob-Programming-Session implementierten wir den API Aufruf. In anschließenden Debug-Sessions verfeinerten wir den System-Prompt, sodass die Qualität der E-Mails unsern Anspruch entsprach. Ein weiterer wesentlicher Punkt war das wir die erzeugten Email in Form eines strukturierten HTML Formats haben wollten. Wir haben das HTML Format bewusst gewählt, um die Authentizität und Qualität unser Emails zu erhöhen, die über einfach Textnachrichten hinausgehen. Wir mussten hier noch einige Anpassungen machen, damit das gewünschte Format verlässlich erzeugt wird.
Im weiteren Verlauf des Sprints baute ich für die Phishing-Mails die Kernlogik in dem lokalen Backend-Service . Ich habe Endpunkte fürs Frontend implementiert, die das verwalten und anlegen von von Phishing-Kampagnen erlaubt, sowie das anlegen und verwalten von Email-Empfängerlisten ermöglichen. Hierfür habe ich entsprechende MongoDB-Collections angelegt. Immer wieder wurde im Rahmen dieser Implementierungen im Pair oder Mob gearbeitet. Im Rahmen dieser Implementierung identifizierte ich Schwächen und Unklarheiten im eigentlichen Prozess, was ich auch im abschließenden Review entsprechend anmerkte. Um den Phising-Prozess Robust zu bekommen habe ich vor dem Abschluss des Sprints noch das Fehlerhandling implementiert. Ich nutzte hierfür das Spring Pattern "Controller Advice". Darüber hinaus habe ich abschließend den Code durch gezielte Refactorings sauberer und lesbarer gestaltet um eine Wartung und Weiterentwicklung zu gewährleisten. Erwähnt sei noch, dass die meisten der eingebrachten Änderungen im Rahmen eines testgetriebenen Vorgehens versucht worden zu entwickeln. 
Der Sprint wurde mit einem ausgedehnten Review in der wir die Funktionalität zur Erzeugung der HTML-E-Mails erfolgreich präsentierten abgeschlossen. Um die Implementierungsqualität und den Wissensaustausch zu gewährleisten gingen wir anschließend noch in den technischen Diskurs bei einem Codereview. In unser Retrospektive reflektierten wir den Sprint und unsere Zusammenarbeit bezogen auf das ganze Team durch unsern Projektfortschritt war die Stimmung im Team grundsätzlich sehr positiv.
\section{Sprint 3 21.03.2025 bis 09.05.2025}
Wie ich bereits im dem Eintrag zum letzten Sprint beschrieben habe, fiel mir im Rahmen der Implementierung  der Features für das Phishing-Modul auf, dass der Prozess bezogen auf das Gesamtprodukt noch unsauber oder teilweise unklar ist. Im Rahmen unseres Plannings adressierte ich den Bedarf nochmal über die Prozesse des gesamten Projektes zu reden. Im Fokus stand die Funktionalität der einzelnen Module bezogen auf das Gesamtprodukt. m Rahmen der Durchführung des Workshops  stellte jede Workstreamgruppe nochmal ihren Prozess im Kontext des Gesamtproduktes vor. Bei Unklarheiten diskutierten wir gemeinsam im Kollektiv wie der Prozess aussehen sollte. Ich empfand den Termin aus überaus wert schöpfend für das gesamte Projekt. Auf dieser Basis konnten wir unsere Userstories verfeinern, erweitern und teilweise auch streichen. Für das Phishing-Modul wurden essentielle  Prozessfragen wie, dass der Anwender eine Empfängerliste erst anlegen muss um eine Mailkampagne erstellen zu können oder das eine Email die generiert wird und an verschiedene Empfänger versendet wird, als Kampagne in dem System gehalten und verwaltet wird. In unser Workstreamgruppe stand darüber hinaus noch das das aufsetzen des API-Contracts für das Phising-Modul mit Swagger (OpenAPI) auf dem Plan. Swagger Open Api wird verwendet um Schnittstellen zu beschreiben, die ein Service anbietet. Es ist vor allen Dingen dazu Gedacht, dass sich potenzielle Verwender der Schnittstelle transparent über die Endpunkte und die angebotenen Funktionalitäten informieren können. Wir entschieden uns bewusst dafür diese Spezifikation im Rahmen eines Design-First‘-Ansatz händisch zu erstellen, anstatt sie aus dem Projekt generieren zu lassen. Dies war äußerst zielführend, da wir uns nochmal bewusst Gedanken über die von uns Angebote Schnittstelle machen mussten. 
\begin{figure}[H]
    \centering
    % Hier wird der Pfad zum Ordner "figures" angegeben
    \includegraphics[width=0.9\textwidth]{figures/swagger.png} 
    \caption{Händisch erstellte Swagger Datei im Sprint 3}
    \label{fig:architektur}
\end{figure}
Im laufe dieses Sprints fanden immer wieder punktuelle Code Reviews statt. Ein Beispiel hierfür war die Vorstellung der Sicherheitsarchitektur im lokalen Spring Backend durch einen Teamkollegen (Tom). Dieser Wissenstransfer erwies sich als äußerst Wertvoll für meine eigene Arbeit, da ich auf Basis der vorgestellten Methoden später ähnliche Security-Filter in das das Phishing-Modul Backend implementieren konnte. Wir haben uns intensiv mit der Nutzerführung beim erstellen einer Phishing-Kampagne auseinandergesetzt. Als optimalen Lösungsansatz identifizierten wir einen Stepper beziehungsweise Wizard, die die Umfangreiche Erstellung in logische aufeinanderfolgende Schritte unterteilt. In einer Mob-Programming-Session implementierten wir eine ersten Proof of Concept dieses Wizards. In einen späteren iterativen Prozess überarbeite Sebastian den Wizard in dem er ihn hinsichtlich des UX-Design und der visuellen Gestaltung optimierte.
\begin{figure}[H]
    \centering
    % Hier wird der Pfad zum Ordner "figures" angegeben
    \includegraphics[width=0.8\textwidth]{figures/wizard.png} 
    \caption{Der finale Wizard}
    \label{fig:architektur}
\end{figure}
Ein weiterer technischer Schwerpunkt dieses Sprints lag in dem Aufbau eines Spring Cloud Gateway. Das Gateway wurde als zentrale Komponente zwischen den Lokalen Backend und unsern Modulen geschaltet. Ziel war es eine saubere Trennung zwischen den lokalen Komponenten beim Anwender und unsern Cloud Komponenten zu schaffen sowie eine einheitliche Kommunikation zu gewährleisten.
\begin{itemize}
  \item \textbf{Zentrales Routing}: Es ist als Proxy konzipiert und leitet die eingehen Anfragen an die entsprechenden Module weiter.
  \item \textbf{Sicherheit}: Das Gateway führt eine initiale Rechteprüfung durch, hierbei prüft es dem vom lokalen Backend übergeben Nutzungsschlüssel auf Gültigkeit. Bei Erfolgreicher Prüfung wird vom Gateway ein neues JSON Web Token (JWT) generiert, welches für die interne Kommunikation mit den Modulen verwendet wird.
\end{itemize}
Durch dieses Design sind die einzelnen Module von der Kommunikation von außen entkoppelt. 
Zur Qualitätssicherung dieser Implementierung führte ich eine Reihe von End to End Test durch. Unter Verwendung des API-CLients Bruno teste ich den gesamten Datenfluss vom Lokalen Backend zum Gateway und anschließend zum Phishing-Modul. Um realistische Bedingungen zu testen, entwickelte ich ein Python-Skript für Lasttests, welches 10 gleichzeitige Anfragen an unsere Backends ausführen kann. Dabei identifizierte ich das Problem, dass unser Mistral Agent bei zu vielen zeitgleichen Anfragen mit dem Status Code 429 (Too Many Requests) abbrach. Nach eingehender Recherche wurde festgestellt, dass unser kostenloser Studententarif lediglich zwei gleichzeitige Aufrufe erlaubt. Wir entschieden uns Teamintern in der Entwicklungsphase diesen Tarif zunächst nicht zu erweitern. Um auf die identifizierten Msitral-Api Beschränkungen professionell zu reagieren habe ich zwei Änderungen an dem Aufruf der Mistral-Api eingebracht:
\begin{itemize}
  \item \textbf{Explizites Error-Handling mit Retry-Logik}:Das Backend wurde so erweitert, dass es auf den Fehlercode 429 gezielt reagiert. Bei Auftreten des Fehlercodes wird automatisch ein neuer Versuch eingeleitet (bis zu Maximal drei Versuchen). 
  \item \textbf{Concurrency Control mittels Semaphoren}: Zusätzlich habe einen Semaphore implementiert, dieser limitiert die Anzahl der gleichzeitig ausgehenden Anfragen an die Mistal-API auf maximal zwei Threads. Überzählige Anfragen werden in eine Warteschlange gesetzt.
\end{itemize}
Zum Abschluss des Sprints gab uns Tom nochmal Einblicke in die Umsetzung des Deployments mittels Plesk. Ich empfand diesen Austausch als wirklich interessant und wert schöpfend, da ich bisher deploys immer dierkt über GitHub oder Jenkins gemacht hatte. Ich unterstütze den Prozess indem ich entsprechenden Weebhooks in unsern GitHub-Repositories konfigurierte. Im abschließenden Review wurden  alle Anpassungen präsentiert und diskutiert. Die Abschließende Retrospektive unterstrich die positive Dynamik in der Projektgruppe. Das Team funktioniert gut, die Kommunikation ist effizient und alle Aufgaben wurden zielgerichtet erledigt.